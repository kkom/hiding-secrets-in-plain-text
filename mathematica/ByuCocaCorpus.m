(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



BeginPackage["ByuCocaCorpus`",{"DatabaseLink`"}]

ByuCocaPQuery::usage="Later"
ByuCocaC1Query::usage="Later"
ByuCocaC2Query::usage="Later"
ByuCocaSuperintervalQuery::usage="Later"

Begin["`Private`"]

genConnection[host_,credentials_]:=genConnection[host,credentials]=
OpenSQLConnection[
JDBC["PostgreSQL",host],
"Username"->First[credentials],
"Password"->Last[credentials]
];

genTableName[dataset_,fullN_,n_]:=genTableName[dataset,fullN,n]=
"byu_coca_corpus."<>
"\""<>ToString[fullN]<>"gram_"<>dataset<>
"_"<>ToString[n]<>"\"";

genColumnNames[n_]:=genColumnNames[n]=Map["w"<>ToString[#1]&,Range[n]];

selectRows[conn_,table_,cols_,cFuns_,cCols_,cVals_]:=
selectRows[conn,table,cols,cFuns,cCols,cVals]=
SQLSelect[
conn,
table,
cols,
Apply[And, MapThread[#1[SQLColumn[#2],#3]&,{cFuns,cCols,cVals}]]
];

selectSequenceStatRow[conn_,dataset_,fullN_,S_]:=selectRows[
conn,
genTableName[dataset,fullN,Length[S]],
{"p","c1","c2"},
Table[Equal,{Length[S]}],
genColumnNames[Length[S]],
S
];

getSequenceStat[{},_]:=Throw["Sequence doesn't exist."];
getSequenceStat[rows_List,i_]:=If[
Length[rows]==1,
Flatten[rows][[i]],
Throw["Fetched more than one row corresponding to a sequence."]
];

cutSequences[s_,S_,fullN_,]:={
Take[s,-Min[Length[s],fullN]],
Take[S,-Min[Length[S],fullN-Length[s]]]
};

makeList[x_List]:=x;
makeList[x_]:={x};

p[conn_,dataset_,fullN_,s_,S_]:=
Module[{sCut,SCut},
{sCut,SCut}=cutSequences[makeList[s],makeList[S],fullN];
getSequenceStat[selectSequenceStatRow[conn,dataset,fullN,Join[SCut,sCut]],1]/getSequenceStat[selectSequenceStatRow[conn,dataset,fullN,SCut],1]
];

c[conn_,dataset_,fullN_,s_,S_,cIndex_]:=Module[{sCut,SCut,C1,P,c},
{sCut,SCut}=cutSequences[makeList[s],makeList[S],fullN];
{P,C1}=getSequenceStat[selectSequenceStatRow[conn,dataset,fullN,SCut],{1,2}];
c=getSequenceStat[selectSequenceStatRow[conn,dataset,fullN,Join[SCut,sCut]],cIndex+1];
(c-C1)/P
];

getWord[{}]:=Null;
getWord[rows_List]:=BlockRandom[
SeedRandom[10];
First[RandomChoice[rows]]
];

(*getWord[rows_List]:=First[RandomChoice[rows]];*)

getSuperinterval[conn_,table_,col_,c1_,c2_]:=
getWord[selectRows[
conn,table,col,
{LessEqual,GreaterEqual},{"c1","c2"},{c1,c2}
]];

getSubinterval[conn_,table_,col_,c1_,c2_]:=
getWord[selectRows[
conn,table,col,
{GreaterEqual,LessEqual},{"c1","c2"},{c1,c2}
]];

getPreinterval[conn_,table_,col_,c1_]:=
Flatten[selectRows[
conn,table,{col,"c2"},
{LessEqual,GreaterEqual},{"c1","c2"},{c1,c1}
]];

getPostinterval[conn_,table_,col_,c2_]:=
Flatten[selectRows[
conn,table,{col,"c1"},
{LessEqual,GreaterEqual},{"c1","c2"},{c2,c2}
]];

checkPrevious[conn_,dataset_,fullN_,SCut_]:=
checkPrevious[conn,dataset,fullN,SCut,selectSequenceStatRow[conn,dataset,fullN,SCut]];
checkPrevious[conn_,dataset_,fullN_,SCut_,{}]:=
checkPrevious[conn,dataset,fullN,Rest[SCut]];
checkPrevious[conn_,dataset_,fullN_,SCut_,result_]:=result;

\[Psi][conn_,dataset_,fullN_,v_,S_]:=
Module[{table,col,SCut,P,C1,c1,c2,s,statRow},
SCut=Take[S,-Min[Length[S],fullN-1]];
table=genTableName[dataset,fullN,Length[SCut]+1];
col="w"<>ToString[Length[SCut]+1];

(* dirty hack *)

statRow=checkPrevious[conn,dataset,fullN,SCut];
Print[statRow];

{P,C1}=getSequenceStat[statRow,{1,2}];
{c1,c2}={Floor[C1+P*First[v]],Ceiling[C1+P*Total[v]]};

s=getSuperinterval[conn,table,col,c1,c2];
If[s==Null,s=getSubinterval[conn,table,col,c1,c2]];

If[s==Null,Throw["Couldn't find a superinterval."]];

Print[Append[S,s]];

s
]

ByuCocaPQuery[host_,credentials_,dataset_,fullN_]:=
Function[{s,S},p[genConnection[host,credentials],dataset,fullN,s,S]];

ByuCocaC1Query[host_,credentials_,dataset_,fullN_]:=
Function[{s,S},c[genConnection[host,credentials],dataset,fullN,s,S,1]];

ByuCocaC2Query[host_,credentials_,dataset_,fullN_]:=
Function[{s,S},c[genConnection[host,credentials],dataset,fullN,s,S,2]];

ByuCocaSuperintervalQuery[host_,credentials_,dataset_,fullN_]:=
Function[{v,S},\[Psi][genConnection[host,credentials],dataset,fullN,v,S]];

End[]

EndPackage[]
