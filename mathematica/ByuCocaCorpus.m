(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



BeginPackage["ByuCocaCorpus`",{"DatabaseLink`"}]

ByuCocaPQuery::usage=
"ByuCocaPQuery[host,credentials,dataset,NFull] generates a function p[s,S] which gives the probability of occurence of a sequence s given a preceding sequence S. The conditional or context S is automatically reduced until there is a match."
ByuCocaC1Query::usage=
"ByuCocaPQuery[host,credentials,dataset,NFull] generates a function c1[s,S] which gives the cumulative (excluding the event) probability of occurence of a sequence s given a preceding sequence S. The conditional or context S is automatically reduced until there is a match."
ByuCocaC2Query::usage=
"ByuCocaPQuery[host,credentials,dataset,NFull] generates a function c1[s,S] which gives the cumulative (including the event) probability of occurence of a sequence s given a preceding sequence S. The conditional or context S is automatically reduced until there is a match."
ByuCocaMatchingIntervalQuery::usage=
"ByuCocaMatchingIntervalQuery[host,credentials,dataset,NFull] generates a function matchingIntervalQuery[v,S] which given an interval v and a preceding sequence S returns the next decoded symbol s. The symbol corresponds to whichever of the current interval is found first: a superinterval, an arbitrary subinterval, or a pre/post interval (depending on which one contains a larger portion of the search interval)."

Begin["`Private`"]

(* used for ensuring that input to a function is always a list *)
makeList[x_List]:=x;
makeList[x_]:={x};

genConnection[host_,credentials_]:=genConnection[host,credentials]=
OpenSQLConnection[
JDBC["PostgreSQL",host],
"Username"->First[credentials],
"Password"->Last[credentials]
];

genTableName[dataset_,NFull_,n_]:=genTableName[dataset,NFull,n]=
"byu_coca_corpus."<>
"\""<>ToString[NFull]<>"gram_"<>dataset<>"_"<>ToString[n]<>"\"";

genColumnNames[n_]:=genColumnNames[n]=Map["w"<>ToString[#1]&,Range[n]];

(* generic function to select rows from a table *)
selectRows[conn_,table_,cols_,cFuns_,cCols_,cVals_]:=
selectRows[conn,table,cols,cFuns,cCols,cVals]=
SQLSelect[
conn,
table,
cols,
Apply[And, MapThread[#1[SQLColumn[#2],#3]&,{cFuns,cCols,cVals}]]
];

(* selects p, c1 & c2 columns for a given sequence *)
selectSequenceStats[conn_,dataset_,NFull_,S_]:=
selectRows[
conn,
genTableName[dataset,NFull,Length[S]],
{"p","c1","c2"},
Table[Equal,{Length[S]}],
genColumnNames[Length[S]],
S
];

(* gets specified statistics for a row assumed to represent statistics of a single sequence, throws exceptions if isn't given a single row *)
getSequenceStat[{},_]:=Throw[Null,"No rows"];
getSequenceStat[rows_List,i_]:=If[
Length[rows]==1,
Flatten[rows][[i]],
Throw[Null,"Multiple rows"]
];

(* cuts conditional part of the query to match order of the model *)
fitS[S_,NFull_]:=Take[S,-Min[Length[S],NFull-1]];
fitS[s_,S_,NFull_]:=
If[
Length[s]>NFull,
Throw[Null,"Cannot submit query of order higher than the model."],
Take[S,-Min[Length[S],NFull-Length[s]]]
]

(* queries database directly for a conditional probability of a sequence, will throw exceptions if the respective n-grams aren't in the database *)
rawP[conn_,dataset_,NFull_,s_,S_,_]:=getSequenceStat[selectSequenceStats[conn,dataset,NFull,Join[S,s]],1]/getSequenceStat[selectSequenceStats[conn,dataset,NFull,S],1];

(* queries database directly for a comulative conditional probability of a sequence, will throw exceptions if the respective n-grams aren't in the database *)
rawC[conn_,dataset_,NFull_,s_,S_,cIndex_]:=
Module[{C1,P,c},
{P,C1}=getSequenceStat[selectSequenceStats[conn,dataset,NFull,S],{1,2}];
c=getSequenceStat[selectSequenceStats[conn,dataset,NFull,Join[S,s]],cIndex+1];
(c-C1)/P
];

(* queries database for a given conditional probability, reduces the context if necessary *)
probabilityQuery[conn_,dataset_,NFull_,s_,S_,rawFun_,cIndex_:Null]:=
probabilityQuery[conn,dataset,NFull,s,S,rawFun,cIndex]=
Catch[
rawFun[conn,dataset,NFull,s,S,cIndex],
"No rows",
Function[{value,tag},
If[Length[S]==0,
Throw[Null,"Cannot decrease order of the query condition any more."],
probabilityQuery[conn,dataset,NFull,s,Rest[S],rawFun,cIndex]
]
]
];

(* final conditional probability functions with automatically reduced context *)
p[conn_,dataset_,NFull_,s_,S_]:=probabilityQuery[conn,dataset,NFull,s,S,rawP,Null]
c1[conn_,dataset_,NFull_,s_,S_]:=probabilityQuery[conn,dataset,NFull,s,S,rawC,1]
c2[conn_,dataset_,NFull_,s_,S_]:=probabilityQuery[conn,dataset,NFull,s,S,rawC,2]

(* get the actual word from a super-/subinterval query *)
(* select first row for consistency in the subinterval case, I am not completely sure of the repercussions of this arbitrary choice, it should be more elegant to select a deterministic random row based on for example S *)
getIntervalWord[{}]:=Null;
getIntervalWord[rows_List]:=First[First[rows]];

getSuperinterval[conn_,table_,col_,c1_,c2_]:=
getIntervalWord[selectRows[
conn,table,col,
{LessEqual,GreaterEqual},{"c1","c2"},{c1,c2}
]];

getSubinterval[conn_,table_,col_,c1_,c2_]:=
getIntervalWord[selectRows[
conn,table,col,
{GreaterEqual,LessEqual},{"c1","c2"},{c1,c2}
]];

getPreinterval[conn_,table_,col_,c1_]:=
Flatten[selectRows[
conn,table,{col,"c2"},
{Less,Greater},{"c1","c2"},{c1,c1}
]];

getPostinterval[conn_,table_,col_,c2_]:=
Flatten[selectRows[
conn,table,{col,"c1"},
{Less,Greater},{"c1","c2"},{c2,c2}
]];

rawMatchingIntervalQuery[conn_,dataset_,NFull_,v_,S_]:=Module[
{table,col,P,C1,C2,c1,c2,cMid,s},

table=genTableName[dataset,NFull,Length[S]+1];
col="w"<>ToString[Length[S]+1];

(* calculate what cumulative frequencies range the new word needs to be around/inside/on the border of *)
{P,C1,C2}=getSequenceStat[selectSequenceStats[conn,dataset,NFull,S],{1,2,3}];
{c1,c2}={Floor[C1+P*First[v]],Ceiling[C1+P*Total[v]]};

(* This step is needed when we are in the process of getting *inside* the interval.

Imagine the following situation

1. Found the last superinterval around the scaled interval, no proper subinterval yet
2. In order to find a subinterval first need to choose a pre/post interval
3. Pre/post interval will partly span outside of the interval as well as at least half of its inside
4. Notice that superinterval search will always fail in this case, but subinterval search might find a subinterval outside of the actual scaled interval
5. For this reason we modify the search interval to be a maximal subinterval of the scaled interval
*)
{c1,c2}={Max[c1,C1],Min[c2,C2]};

s=getSuperinterval[conn,table,col,c1,c2];
If[s==Null,s=getSubinterval[conn,table,col,c1,c2]];
If[s==Null,
{s,cMid}=getPreinterval[conn,table,col,c1];
If[cMid-c1<c2-cMid,
{s,cMid}=getPostinterval[conn,table,col,c2];
]
];

If[s==Null,Throw[Null,"Couldn't match an interval. This isn't supposed to happen - fix the program."]];

s
];

matchingIntervalQuery[conn_,dataset_,NFull_,v_,S_]:=
matchingIntervalQuery[conn,dataset,NFull,v,S]=
Catch[
rawMatchingIntervalQuery[conn,dataset,NFull,v,S],
"No rows",
Function[{value,tag},
If[Length[S]==0,
Throw[Null,"Cannot decrease order of the interval matching context any more. This isn't supposed to happen - fix the program."],
matchingIntervalQuery[conn,dataset,NFull,v,Rest[S]]
]
]
];

ByuCocaPQuery[host_,credentials_,dataset_,NFull_]:=Function[{s,S},
p[
genConnection[host,credentials],
dataset,
NFull,
makeList[s],
fitS[makeList[s],makeList[S],NFull]
]
];

ByuCocaC1Query[host_,credentials_,dataset_,NFull_]:=Function[{s,S},
c1[
genConnection[host,credentials],
dataset,
NFull,
makeList[s],
fitS[makeList[s],makeList[S],NFull]
]
];

ByuCocaC2Query[host_,credentials_,dataset_,NFull_]:=Function[{s,S},
c2[
genConnection[host,credentials],
dataset,
NFull,
makeList[s],
fitS[makeList[s],makeList[S],NFull]
]
];

ByuCocaMatchingIntervalQuery[host_,credentials_,dataset_,NFull_]:=Function[{v,S},
matchingIntervalQuery[
genConnection[host,credentials],
dataset,
NFull,
v,
fitS[S,NFull]
]
];

End[]

EndPackage[]
